# ExercÃ­cios - agora, a prÃ¡tica

Para encerrarmos o conteÃºdo do dia com chave de ouro temos aqui alguns exercÃ­cios para fixar o nosso aprendizado sobre o `TAD LinkedLists` ðŸ˜€. Ã‰ um  *momento que temos que festejar* .

| ![Carlton - It](https://content-assets.betrybe.com/prod/Carlton%20-%20It.gif) |
| --------------------------------------------------------------------------- |
| Carlton - Itâ€™s not unusual to have fun with anyone                         |

## ExercÃ­cio 1:

 *Aprimorando a classe `Lista`* : nossa classe `Lista` atende as principais operaÃ§Ãµes que essa `TAD` nos oferece, mas que tal melhorarmos? Para isso, vocÃª deve adicionar os seguintes mÃ©todos:

**a.** A operaÃ§Ã£o `clear` nos permite remover todos os `Nodes` da lista;

**b.** A operaÃ§Ã£o `__get_node_at` nos permite acessar o `Node` em qualquer posiÃ§Ã£o da lista.

> ApÃ³s criada as operaÃ§Ãµes anteriores, refatore os seguintes mÃ©todos para que utilizem a `__get_node_at` ante iteraÃ§Ãµes:

* **insert_at** ;
* **insert_last** ;
* **remove_last** ;
* **remove_at** ;
* **get_element_at** .

> âš ï¸ **FaÃ§a a anÃ¡lise de complexidade da sua soluÃ§Ã£o.**

## ExercÃ­cio 2:

 *Nova busca* : atÃ© o momento nossa estrutura consulta elementos atravÃ©s da posiÃ§Ã£o. Nesta atividade serÃ¡ necessÃ¡rio criar uma funÃ§Ã£o chamada `def index_of(self, value)`, onde ela serÃ¡ responsÃ¡vel por consultar na lista a existÃªncia do valor informado e retornar a posiÃ§Ã£o da primeira ocorrÃªncia. Caso o valor nÃ£o exista, considere retornar `-1`. Esta funÃ§Ã£o deve respeitar a complexidade `O(n)`.

> âš ï¸ **FaÃ§a a anÃ¡lise de complexidade da sua soluÃ§Ã£o.**
>
